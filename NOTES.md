## common

{...} - react elements, supports only elements and expressions not an object, ect.
<... /> - react components
в качестве пропсов можно передавать всё в т.ч. jsx
React-элементы нельзя именять они должны оставаться иммутабельными
соотв. при работе с ними мы должны делать их копию для безопасной работы

Основная причина использования классов вместо функций это возможность хранить состояние компонента

## Управление состоянием

setState(updater, cb)

updater(state, props) должна вернуть новый объект с обновлённым состоянием
можно пользоваться аргументами state/props, но не менять их

в поле state попадает предыдущее состояние компонента
значения props будут актуальными на данный момент

когда вызывается setState, React объединяет новое состояние с текущим
например, если у нас:

```js
this.state = {
  comments: [],
  posts: [],
};
```

то мы можем обновить эти поля по отдельности, React объединяет
состояния поверхностно, по этому вызов this.setState({comments}) не повлияет на posts

cb() вызываеться ПОСЛЕ обновления state
вместо cb ребята рекомендуют использовать componentDidUpdate

если наш новый state никак не зависит от предыдущего state, то можно использовать
объект как аргумент setState, в противном случае cb

Состояние как правило являеться локальным, оно доступно только для самого компонента
и скрыто от других, но в то же время компонент может передать своё состояние вниз по дереву
в виде пропсов дочерних компонентов

## Собственные события

Как удалять компоненты?

Компонент, который должен быть удалён, должен передать кастомное событие
вверх по иерархии, управляющему компоненту, а тот в свою очередь (если он НЕ является источником данных),
должен передать событие выше по иерархии, пока мы не дойдём до "источника данных"

Для того что бы можно было удалить эл. его нужно удалять из "источника данных",
например, если мы рисуем список, то мы пользуемся массивом объектов, получается с помощью
кастомного события на удаляемом компоненте мы должны передать сигнал, в управляющий компонент,
что бы он в свою очередь удалил удаляемый компонент из "источника данных", т.е. из массива

Кастомное событие мы передаём как и props в место вызова компонента (в сам компонент)
Т.е. он становиться частью props, а в самом компоненте, мы должны его принять и поставить
"стандартный" обработчик (например onClick) на элемент, который будет вызывать кастомное событие
можно назвать это пробрасыванием колбэка

и таким образом мы можем двигаться вверх по иерархии,
навешивая кастомное событие на родителя

## summary

Любой компонент может генерировать собственные события (onDone, onAdded, ...)
Достаточно передать cb функцю как props, а затем вызвать её из компонента, когда наступило собыие

не забываем, что state главного компонента это ссылочный тип, не забываем его копировать при
изменении

Централизовать управление данными - хорошая практика
Если данные нужно использолвать в нескольких компонентах - их нужно хранить в род. компоненте

## контролируемые компоненты

Как сделать dom-эл контролируемым?
Передать ему state

Например записать в аттрибут value у input, this.state.prop
И после перерисовки, текущее значение поля состояния, попадёт в value

не обязательно добавлять какие-то поля в объект отрисовывания
например isHidden: true
можно просто отфильтровать state перед перерисовкой и оставить только нужные элементы

## жизненный цикл компонента

НИКОГДА НЕ ВЫЗЫВАЕМ САЙД ЭФФЕТЫ В КОНСТРУКТОРЕ
componentDidMount - запускается **после** того, как компонент
отрендерился в DOM

порядок в котором вызываются методы при добавлении компонента на страницу

1. Вызывается конструктор компонента, инициализируеться начальный state
2. Вызывается метод render
3. Вызывается метод componentDidMount -> если в нём есть какая-то логика
   например setTimeout, то она выполняеться
4. Если мы использовали setState / измениили props, то React выполняет render() затем componentDidUpdate()
5. Если мы удаляем компонент из DOM, то вызывается метод componentWillUnmount,
   в нём мы можем сбросить таймер

Изолировать код, который обрабатывает данные
Отделять модель данных API от модели данных приложения
Не забываем про React.Fragment вместо div-обёртки
Стараемся разделять логику и рендеринг
editor playgroud

### componentDidMount:

вызывается когда DOM-элемент уже на странице
используется для инициализации, получения данных, работы с DOM .ect
не используем конструктор для кода, который создаёт сайд-эффекты

### componentDidUpdate:

componentDidUpdate(prevProps, prevState)
! ЕСЛИ МЫ СОБИРАЕМСЯ МЕНЯТЬ STATE, ТО ОБПЯЗАТЕЛЬНО НУЖО ПРОВЕРЯТЬ
! РАЗЛИЧИЕ МЕЖДУ ПРЕДЫДУЩИМИ ПРОПСАМИ И ТЕКУЩИМИ
! И ЕСЛИ РАЗНИЦА ЕСТЬ,ТО ТОЛЬКО ТОГДА ОБНОВЛЯТЬ STATE
вызывается поле того как компонент обновился
обновляеться, после того как обновились props или state или forceUpdate
вызывается после render

### componentWillUnmount:

используется для очистки ресурсов
в момент вызова компонент всё-ещё находится на странице
вызывается перед тем, как компонент будет удалём,

что делает его идеальным для использования в нём clearInterval или отмены запросов к серверу и других
функции или api которые должны быть удалены, если компонента нет на странице

### componentDidCatch:

ловит ошибки только в методах жизненного цикла компонента
didMount, didUpdate, .ect
компоненты, которые содержат didCatch называются errorBoundry (граница ошибок)
потому что ловят ошибки (ограничивают область действия ошибок) ниже себя по иерархии у детей
componentDidCatch(error, info)
error - стандартые ошибки JS
info - ошибки сгеренированные самим React

## подъём состояния

Для любых изменяемых данных в React должен быть один "источник истины"

## работа с api

сетевой код необходимо изолировать от кода компонентов
если необходимо трансформируем дынные до того, как их получит компонент
можно в сервисе получения этих самых данных
обрабатывать ошибки и состояния загрузки
разделяем ответсвенность у компонентов: логику и рендеринг

## Паттерны React

Передаём в компоненты функции, не только обработчики, но и другие,
например для отпраки запроса на сервер, тогда компонент становиться независимым
от источника данных

#### паттерн рендер-функция

это функция, которая передаётся в реакт-компонент и занимаеться
отрисовкой какой-то части компонента
такая функция обычно возвращает строку или react-элемент

```js
<Card
   renderBody={(text) => <p>text</p>}
>
```

внутри компонента мы вызываем функцию и передёем агрумент text

передаём в компоненты функции (ещё раз), в том числе которые могут работать
внутри массивов, форматировать вывод текстового содержимого например
или вообще можем возвращать из неё jsx

#### паттерн свойство-элемент

в качестве значения свойства можно передавать React-елемент
Так можно создавать элементы-контейнеры
или элементы, которые умеют выбирать что рендереить в зависимости от условия

#### children

компоненту можно передавать одно из свойств, помести его в тело элемента

```js
<Card>check</Card>
```

это свойство (check) будет доступно через props.children
поддерживает любые типы данных: элементы, функции, объекты и др.

стараться выносить детали получения данных в отдельные функции
в таком виде компонент может работать с разными данными

## HOC

может преобразовывать свойства перед тем, как передавать их компоненту
например изменять их имена и выбирать, какие именно свойства нужно передать оборачеваемому компоненту
при помощи функции можно определить такое повоедение для каждого компонента

## Context

Служит для того что бы решать проблему глобальных данных
Вместо того что бы props передавать через все слои приложения, данные можно передавать через контекст
с помощью конекста мы можем сделать так, что бы компоненты не создавали объекты сервиса, а получали его

совершенно не обязательно должен быть статичным
главное, научить компоненты ниже по иерархии реагировать на изменения контекста
в этом поможет componentDidUpdate

## Default props

Это объект, ключи которого это названия свойств

```js
ItemList.defaultProps = {
  onItem: () => {},
};
```

## Hooks

Дают возможность компонентам-функциям работать как с состоянием,
жизненным циклом и контекстом

## userState

Принимает один аргумент, который по итогу станет начальным state
функционального компонента.
Возвращает массив всегда состоящий из двух элементов, которые мы можем
назвать как угодно.
Первый элемент это текущий state
Второй элемент это функция-setter, которую нужно использовать
по аналогии с this.setState (классовых компонентов)
Если наш новый state не зависит от предыдущего, то мы можем
класть новое значение например:

```js

const increaseFontSize = () => {
  const [fontSize, setFontSize] = useState(16);

  return (
      // кладём новое значение
      <button onClick={() => setFontSize(24)}>+</button>
      <div style={fontSize: fontSize}></div>
  )
};

```

а если нужно изменять state, который зависит от предыдущего состояния,
то

```js

const increaseFontSize = () => {
  const [fontSize, setFontSize] = useState(16);

  return (
      // используем предыдущее состояние, что бы увеличить размер шрифта
      <button onClick={() => setFontSize((fontSize) => fontSize + 1)}>+</button>
      <div style={fontSize: fontSize}></div>
  )
};

```

так же, переданный в функцию-сеттер, updaterCb полностью заменяет
предыдущий state, не объединяя пред. значения.
например:

```js
const updateUser = () => {
  const [user, setUser] = useState({ name: "John", age: 24 });

  // этот сеттер вернёт новый объект БЕЗ поля age
  setUser({ name: "Mike" });

  // что бы сохранить пред. поля, используем updateCb
  setUser((prevUser) => {
    return { ...prevUser, name: "Mike" };
  });
};
```

так же useState можно вызвать с аргументом-функцией, это полезно в случаях, когда мы не хотим, что бы state вычислялся при каждой перерисовке, но только при первой, в случаях, когда начальный state какое-то сложное вычисление

например:

```js
const [count, setCount] = useState(() => 4);
```

так же, если, переданное в функцию-setter значение равно предыдущему значению state, то ре рендера компонента не произойдёт, используеться сравнение Object.is

## useContext

Используется когда компоненту нужно получить значение из контекста
Получает значение из заданного контекста
Код создания контекста и установки передаваемого значения остаётся без изменений.

в useContext() передаётся именно объект-контекста (а не Consumer)
например:

```js
const TextContext = React.createContext();
const DigitContext = React.createContext();

const Para = () => {
  // контекстов может быть несколько
  const text = useContext(TextContext);
  const digit = useContext(DigitContext);

  return (
    <p>
      {text} - {digit}
    </p>
  );
};

const App = (props) => {
  return (
    <div className={`app `}>
      <TextContext.Provider value="check it out">
        <DigitContext.Provider value="100500">
          <Para />
        </DigitContext.Provider>
      </TextContext.Provider>
    </div>
  );
};
```

## useEffect

Даёт возможность выполнять побочные эффекты в функциональных компонентах.

Другими словами useEffect представляет собой совокупность
DidMount(), DidUpdate(), WillUnmount()

Это будет хорошим выбором, когда нам нужно сделать запрос,
повесить обработчик или таймер, и удалить их.

Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют сброса.

#### Эффекты без сброса:

Сетевые запросы, изменения DOM вручную, логирование и т.д.

useEffect выполняется после каждого render'а и обновления (т.е. компонент уже на странице, аналогично componentDidMount()/componentDidUpdate())

Эффекты выполняются после КАЖДОГО рендера
Когда React рендерит наш компонент, он запоминает эффект, который мы использовали, и запускает его после того, как обновит DOM. Это будет происходить при каждом рендере, в том числе и при первоначальном

useEffect(effect)
принимает effectCb, внутри этого cb мы выполняем запросы и т.д.

#### Эффекты со сбросом:

Что бы отменить подписку мы можем использовать, ту же функцию useEffect
но возвращая из effectCb другую функцию, которая внутри себя
будет отменять, подписку или т.п.

например:

```js
const onKeyDown = (evt) => {
  // logic...
};

useEffect(() => {
  document.addEventListener("keydown", onKeyDown);

  return () => document.removeEventListener("keydown", onKeyDown);
});
```

React будет сбрасывать эффект перед тем, как компонент размонтируется
React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.

Мы можем использовать и несколько эффектов. Это даёт нам возможность разделять разную несвязанную между собой логику между разными эффектами.

React будет выполнять каждый используемый эффект в компоненте, согласно порядку их объявления.

Мы можем сделать так, чтобы React пропускал вызов эффекта, если определённые значения остались без изменений между последующими рендерами.
Чтобы сделать это, нужно передать массив в useEffect вторым необязательным аргументом.

например:

```js
useEffect(() => {
  document.title = `Вы нажали ${count} раз`;
  // Перезапускать эффект только если count поменялся
}, [count]);
```

Если count будет равен 5 и наш компонент повторно рендерится с тем же значением,
React сравнит [5] из предыдущего рендера и [5] из следующего рендера. Так как, все элементы массива остались без изменений (5 === 5), React пропустит этот эффект.

Если мы хотим использовать эту оптимизацию, нужно обратить внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом.
В противном случае, наш код будет ссылаться на устаревшее значение из предыдущих рендеров.

Если мы хотим запустить эффект и сбросить его только один раз (при монтировании и размонтировании), мы можем передать пустой массив ([]) вторым аргументом.

React откладывает выполнение useEffect, пока браузер не отрисует все изменения

Основные правила для использования хуков

не вызывать хуки в обычной функции
не вызывать хуки в условиях и циклах

## Router

Роутер это компонент которым нужно оборачивать всё приложение

Что бы реднерить вложенный Route, нужно не забыть добавить в
родительский Route компонент <Outlet/>, в то место, куда мы хотим, что бы вложенный компонент рендерился.

Что бы получить параметры во вложенном компоненте, нам следует
использовать хук useParams

useParams вернёт объект с информацией из path вложенного компонента
например:

```js
<Route path="invoices" element={<Invoices />}>
  <Route path=":invoiceId" element={<Invoice />} />
</Route>;

// внутри компонента забираем переданную строку
// она будет называться так же как и в path
const Invoice = () => {
  const { invoiceId } = useParams();

  return <h2>Invoice #{invoiceId}</h2>;
};
```

## Redux

Решает проблему управления состоянием в приложении

Предлаегает хранить state в одном "глобальном" объекте

функция reducer обновляет глобальный state в ответ на actions (действия)

объект store координирует обновления

### Reducer

это функция, которая получает два аргумента
первое значение это текущий state, а второе значение
это action объект с полем type
внутри reducer мы проверяем это поле и в зависимости
от значения этого поля, мы выполняем какое-то действие

если в action передано действие, которое мы не знаем как
обрабатывать мы должны вернуть текущий state без изменений

если state === undefined, то мы должный вернуть первончальное значение

### Redux store

что бы получить экз. store вызываем
createStore (deprecated), он возвращает "тонкую" обёртку
над reducer

в обёртке есть несколько полезных методов

getState - возвращает текущий state
dispatch - обновляет state
subscribe - принимает cb-функцию, слушает изменения на store, если изменения произошли - вызывает cb (используется для обновления UI)

так же в dispatch можем передавать объект, не только с action.type, а так же
payload (полезная нагрузка), в которую можем помещать какие то данные из вне
например, запрос из БД

#### Redux bindActionCreators

принимает на вход два аргумента

```js
const inc = () => ({ type: "INC" });
// action функция которая говорит reducer как менять state
// или объект с таками функциями
// dispatch текущего store
bindActionCreators(inc, dispatch);
bindActionCreators({ incDispatch: inc }, dispatch);
```

возвращает объект со связанными с текущим store функциями

```js
const { incDispatch } = bindActionCreators({ incDispatch: inc }, dispatch);
```

созданные таким образом функции делают сразу два действия - создание действия (action) и отправка action в dispatch()

компактные компоненты - залог чистого кода, который легко поддерживать
фнукция bindActionCreators очень сильно помогает

### Reducer naming convention

[тип запроса]_[объект]_[действие]
FETCH_BOOKS_REQUEST

презентационные компоненты отвечаю только за рендер
компоненты-контеёнеры работают с redux, реализуют loading, error, ect.

### useDispatch

Сслыка всегда стабильна, если передавать одинаковый инстанс store в Provider, как это обычно и бывает. Соотв. можно безопасно использовать dispach в зависимостях useEffect

### useSelector

лучше передавать именованную функцию первым аргументом, что бы не ломались внутренние оптимизации

когда был вызван dispatch, useSelector выполнит сравнение по ссылке предыдущего значения возвращенного из selector и текущуего, и если начения не поменялись, то ре реднер выполнен не будет

useSelector по умолчанию выпонлянет === сравнение ссылок, не поверхностное сравнение

Можно вызывать useSelector несколько раз в одном функциональном компоннете
Каждый вызов будет создавать новую подписка на Redux-store

Когда функциональный компонент рендериться, функция переданная аргументом в useSelector(selectorFn => ...) будет вызвана и результат будет возвращён из useSelector. Закешированный результат может быть возвращён без повторного вызова useSelector, если предыдущая selectorFn являеться той же самой функцией, например была создана вне компонента, но передана в useSelector

```js
const getUser = (state) => state.user;

const Component = () => {
  const user = useSelector(getUser);
};
```

Однако когда был вызван dispatch, useSelector принуждает сделать ре-рендер, только в том случае, если резултьтат пред. вызова selectorFn, отличается от текущего результата

Так же стоит повторить, что сравнения результатов возвращенных из selectorFn по умолчанию сравниваются по строгому ссылочному равенству
Это отличается от connect(), т.к. он делает поверхностное сравнение объекта, т.е. сравнение каждого поля и решает, следует ли ре-рендерить компонент, другими словании connect не важно, был ли создан новый объект, он будет смотреть не изменились ли поля.
Если возвращать из useSelector каждый раз новый объект, то это будет вызывать повторные рендеры, если мы хотим этого избежать, можно вызывать useSelector несколько раз и получить нужные поля

### Working with Redux Reducer

Мы не можем менять существующий state, что бы его обновить нужно, если массив
создать новый массив, положить в него часть неизменённых элементов, добавить новые
Мы не можем изменять сущ. массив или объект, не можем изменять сущ. элементы
Каждый раз когда мы хотим что то измнить, нужно создавать новый массив или объект

Как только reducer становится сложныи сразу упрощаем его
Работаем со структурой глобального state:
объединяем свойства в объекты
Выносим логику обновления объектов из глобального state в отдельные ф-ции

Не обязательно переносить state всех компонентов в redux, например
внутри state компонента можно оставить логику связанную с рендерингом (показ или скрытие компонента)

Так же необязательно создавать поля в state redux, котрые можно вычислить на основе уже существующих полей, взамен этого мы можем взять все интресующие поля из redux state с помощью useSelector и использовать их в ответственном за эти вычисления компоненте

### Optimizations

Если компонент использует одни и те же пропсы или не использует или использует, но не часто, то его можно обернуть в React.memo()
Стоит иметь ввиду, если в пропсы передаётся cb-функция, то мемоизация работать не будет, т.к. с каждым рендером в компонент будет попадать новая функция, что бы починить мемо, нужно обернуть функцию в useCallback
